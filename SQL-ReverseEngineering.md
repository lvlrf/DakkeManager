بله. در ادامه نسخه مرتب، استاندارد، و آماده‌ی قرارگیری در GitHub به‌صورت **Markdown** را می‌دهم (با TOC، تیترهای یکدست، بخش‌بندی شفاف، و Query Pack).

> کافیست این را به فایل مثلاً `HOLoo-SQL-DB-Notes.md` کپی کنید.

````md
# مستند تحویل پروژه
## استخراج و همگام‌سازی داده‌های هلو (کالا/قیمت/موجودی/گروه‌بندی) از SQL Server

> نسخه: 1.0  
> وضعیت: تحویل به تیم ادامه‌دهنده  
> دامنه: شناخت ساختار DB هلو + تست‌های میدانی SQL + تعیین قدم‌های بعدی برای قطعی‌سازی مسیرهای UI

---

## فهرست مطالب
- [هدف این سند](#هدف-این-سند)
- [0) دامنه و اصول پروژه](#0-دامنه-و-اصول-پروژه)
- [1) محیط و محدودیت‌ها](#1-محیط-و-محدودیتها)
- [2) موجودیت‌ها و جدول‌های کلیدی (یافته‌ها)](#2-موجودیتها-و-جدولهای-کلیدی-یافتهها)
- [3) تست‌های عملی انجام‌شده](#3-تستهای-عملی-انجامشده)
- [4) Trigger / FK و پیچیدگی‌های پنهان](#4-trigger--fk-و-پیچیدگیهای-پنهان)
- [5) فرضیه گروه‌بندی بر اساس Prefix کد کالا (A_Code)](#5-فرضیه-گروهبندی-بر-اساس-prefix-کد-کالا-a_code)
- [6) خروجی‌های هدف و وضعیت فعلی](#6-خروجیهای-هدف-و-وضعیت-فعلی)
- [7) تصمیم کلیدی: «قیمت اصلی» از کجا؟](#7-تصمیم-کلیدی-قیمت-اصلی-از-کجا)
- [8) برنامه قطعی‌سازی (Next Steps)](#8-برنامه-قطعیسازی-next-steps)
- [9) Query Pack (کوئری‌های آماده استفاده)](#9-query-pack-کوئریهای-آماده-استفاده)
- [10) ریسک‌ها و نکات احتیاطی](#10-ریسکها-و-نکات-احتیاطی)
- [11) جمع‌بندی مدیریتی برای تحویل](#11-جمع‌بندی-مدیریتی-برای-تحویل)
- [12) چک‌لیست تحویل برای تیم بعدی](#12-چک‌لیست-تحویل-برای-تیم-بعدی)

---

## هدف این سند
این سند خروجی تلاش‌های انجام‌شده برای شناخت ساختار دیتابیس هلو، مسیرهای خواندن/تغییر قیمت و موجودی، و مسیر گروه‌بندی کالاها را مستند می‌کند تا تیم بعدی دقیقاً بداند:

- چه چیزهایی **قطعی** است و چه چیزهایی **هنوز قطعی نیست**
- چه **تست‌هایی انجام شده** و نتیجه چه بوده
- قدم‌های بعدی برای **قطعی‌سازی مسیرهای مبهم** و ادامه پروژه چیست

---

## 0) دامنه و اصول پروژه

### 0.1 دامنه (MVP/هدف عملیاتی)
1) استخراج لیست کالاها با فیلدهای کلیدی: **کد، نام، قیمت، موجودی‌ها، (در صورت امکان) گروه/زیرگروه**
2) مقایسه و همگام‌سازی قیمت‌ها بین شعب/دیتابیس‌ها (هدف نهایی)
3) اعمال تغییرات کنترل‌شده روی کالاها (**نام/قیمت/موجودی**) بدون آسیب به تاریخچه فاکتورها
4) امکان ساخت گروه اصلی/زیرگروه و انتساب (در صورت قطعی‌شدن مسیر واقعی UI)

### 0.2 اصول و خط قرمزها
- به **جداول فاکتور** برای اصلاح قیمت‌های گذشته **دست نزنید** مگر با آگاهی کامل از گزارش‌ها و منطق داخلی هلو.
- هر تغییر مستقیم در DB باید:
  - روی **کالای تست** انجام شود
  - با **UI و گزارش‌ها** صحت‌سنجی شود
  - در صورت امکان با **SQL Server Trace/Profiler** مسیر واقعی خواندن/نوشتن هلو تأیید شود

---

## 1) محیط و محدودیت‌ها

### 1.1 محدودیت نسخه SQL Server (قطعی)
- موتور SQL Server یا Compatibility Level قدیمی است؛ تابع `TRY_CONVERT` شناخته نمی‌شود.
- جایگزین‌های مورد استفاده:
  - `ISNUMERIC(...) = 1`
  - `CAST(... AS int)`

### 1.2 تولید کدهای عددی جدید (قطعی)
برای تولید کد جدید کالا (در صورت نیاز) از الگوی زیر استفاده و تست شد (به شرط عددی بودن `A_Code`):

```sql
RIGHT('0000000' + CAST(MAX(CAST(A_Code AS int)) + 1 AS varchar(20)), 7)
````

> نکته: باید داده‌های غیرعددی با `ISNUMERIC` فیلتر شوند.

---

## 2) موجودیت‌ها و جدول‌های کلیدی (یافته‌ها)

### 2.1 جدول کالاها: `dbo.ARTICLE` (قطعی)

* جدول اصلی نگهداری اطلاعات پایه کالاها
* کلید کالا: `A_Code` از نوع `varchar(7)` (Primary Key)
* نام کالا: `A_Name`
* قیمت فروش داخل کالا: `Sel_Price` (float)
* موجودی‌ها: `Exist` و `Exist2` (float)
* گروه اصلی روی کالا: `M_Code` (varchar(5), nullable)

**غیرقطعی**

* اینکه UI هلو “قیمت اصلی/مرجع” را دقیقاً از `ARTICLE.Sel_Price` می‌خواند یا از `ArticlePrice` (یا ترکیبی)؛ احتمالاً وابسته به فرم/ماژول است.

---

### 2.2 جدول قیمت‌ها: `dbo.ArticlePrice` (قطعی)

* قیمت‌های سطح‌بندی‌شده با `SelID`
* الگوی رکورد: `A_Code + SelID + Sel_Price + ModifyDate`
* برای `SelID=1` عملیات Update/Insert (Upsert) انجام شد و ذخیره شد.

**آمار قطعی اختلاف‌ها**

* Total کالاها: **29071**
* MissingInArticlePrice (SelID=1): **15495**
* MissingInArticle (ARTICLE خالی ولی Price هست): **2**
* Different (ARTICLE و Price متفاوت): **22132**

**یافته قطعی دیگر**

* تکراری نبودن رکورد قیمت: کوئری `GROUP BY A_Code, SelID HAVING COUNT(*)>1` خروجی نداشت ⇒ برای هر `(A_Code, SelID)` رکورد تکراری مشاهده نشد.

**غیرقطعی**

* علت اختلاف‌ها و سیاست صحیح تغییر قیمت هنوز قطعی نیست (نیازمند UI/Trace).

---

### 2.3 آیتم‌های فاکتور: `dbo.FACTART` (قطعی)

* قیمت واحد آیتم فاکتور مستقل ذخیره می‌شود:

  * `Price_BS` = قیمت واحد ثبت‌شده در زمان فاکتور

**نتیجه قطعی مهم**

* تغییر قیمت مرجع کالا نباید قیمت فاکتورهای قبلی را خراب کند (چون `Price_BS` مستقل است).
* برای حفظ تاریخچه: **به FACTART و جداول وابسته دست نزنید.**

**غیرقطعی**

* اینکه همه گزارش‌ها/چاپ‌ها/نمایش‌ها همیشه از `Price_BS` استفاده می‌کنند یا بعضی گزارش‌ها به قیمت مرجع Join می‌کنند هنوز تأیید نشده (UI/Trace لازم است).

---

### 2.4 گروه اصلی: `dbo.M_GROUP` (قطعی)

* ستون‌ها: `M_groupcode`, `M_groupname`
* Insert گروه جدید انجام شد و writable است.
* تولید کد جدید با `MAX + 1` روی کدهای عددی تست شد (مثلاً 22 سپس 23).

**غیرقطعی**

* اینکه UI هلو برای گروه‌بندی کالاها دقیقاً از همین جدول استفاده می‌کند یا مسیر دیگری دارد هنوز باید با UI/Trace تأیید شود.

---

### 2.5 اتصال کالا به گروه اصلی: `ARTICLE.M_Code` (قطعی)

* Join معتبر:

  * `ARTICLE.M_Code ↔ M_GROUP.M_groupcode`
* با `UPDATE` روی یک کالا mapping درست نمایش داده شد.

**نتیجه قطعی و مهم**

* در دیتای فعلی تقریباً همه کالاها گروه ندارند:

  * `ItemsWithoutMCode = 29070`
  * `ItemsWithMCode = 1`
  * `Total = 29071`

---

### 2.6 زیرگروه: `dbo.S_GROUP` (قطعی)

* تعداد رکوردها: **87**
* ستون‌ها: `M_groupcode`, `S_groupcode`, `S_groupname`
* Match حساس به فرمت کد است:

  * `@M='1'` match نمی‌داد
  * `@M='01'` match داد و `MaxS` مقدار داد
* Insert زیرگروه جدید برای یک گروه انجام شد و رکورد ساخته شد.

**غیرقطعی**

* مسیر اتصال کالا ↔ زیرگروه در این نصب هنوز کشف نشده.

---

### 2.7 جدول `dbo.Artclass` (قطعی)

* وجود دارد (A_Code, SIndex, SCode, SClass, ...)
* Primary Key: (A_Code, SIndex)
* اما در DB فعلی خالی است: `COUNT(*)=0`
* نتیجه: فعلاً مسیر عملیاتی زیرگروه از این جدول قابل استفاده نیست.

---

### 2.8 جدول `dbo.HLP_` (قطعی)

* وجود دارد (ستون‌هایی مثل A_Code, M_groupcode, S_groupcode, ...)
* اما خالی است: `COUNT(*)=0`
* `sp_helptext` روی آن طبیعی است جواب ندهد چون table است نه view/SP.

**غیرقطعی**

* ممکن است توسط عملیات داخلی هلو در سناریوهای خاص پر شود (تست نشده).

---

### 2.9 Viewهای جستجو (قطعی)

* `dbo.W_ShowArticleForSearch_Big`
* `dbo.W_ShowArticleForSearchCodes`

ستون‌ها شامل: `A_Code, A_Name, A_Code_C, Exist, Exist2, Buy_Price, ...`

**غیرقطعی**

* متن/منبع دقیق Viewها استخراج نشده؛ برای کشف منبع گروه‌بندی/قیمت بسیار مهم است.

---

## 3) تست‌های عملی انجام‌شده

### 3.1 تغییر نام کالا (قطعی)

* `UPDATE dbo.ARTICLE SET A_Name=... WHERE A_Code=...`
* نتیجه: `1 row affected`
* جمع‌بندی: تغییر نام از طریق ARTICLE عملی است.

### 3.2 تغییر قیمت (قطعی + غیرقطعی سیاست)

**قطعی**

* تغییر قیمت در `dbo.ArticlePrice` برای `SelID=1` انجام و ذخیره شد.
* قیمت فاکتورهای گذشته مستقل است (`FACTART.Price_BS`).

**غیرقطعی**

* مسیر “صحیح و امن” تغییر قیمت در سیستم شما هنوز قطعی نیست:

  * فقط `ArticlePrice`؟
  * فقط `ARTICLE.Sel_Price`؟
  * هر دو؟
  * یا SP داخلی/مسیر UI؟

### 3.3 موجودی: `Exist` / `Exist2` (قطعی + ابهام معنایی)

**قطعی**

* هر دو فیلد در ARTICLE وجود دارند.
* مقادیر منفی در `Exist` دیده شد (مثلاً -4497) ⇒ خروج/فروش ثبت شده اما ورودی/ثبت اولیه صحیح نیست یا منطق انبارداری کامل نیست.
* `Exist2` با UPDATE تغییر داده شد و در SELECT دیده شد.

**غیرقطعی**

* معنای دقیق `Exist2` (انبار دوم یا فیلد کمکی) باید با UI/Trace تأیید شود.

### 3.4 گروه‌بندی (قطعی DB، غیرقطعی UI)

**قطعی**

* Insert گروه اصلی و زیرگروه انجام شد.
* Join گروه اصلی برای کالا از طریق `ARTICLE.M_Code` درست است.

**قطعی و مهم**

* مسیر گروه‌بندی برای اکثر کالاها قابل استخراج نیست چون `M_Code` تقریباً خالی است و `Artclass/HLP_` نیز خالی‌اند.

---

## 4) Trigger / FK و پیچیدگی‌های پنهان

### 4.1 Trigger (قطعی)

* روی جدول‌های کلیدی MVP (`ARTICLE`, `ArticlePrice`, `FACTART`, `M_GROUP`, `S_GROUP`) Trigger مشاهده نشد.
* تنها Trigger مشاهده‌شده: `SARFASL.trUpdateParent`

### 4.2 Foreign Key (قطعی تا حد بررسی انجام‌شده)

* FK استاندارد برای جداول کلیدی MVP مشاهده نشد (یا وجود ندارد یا دسترسی محدود بوده).

---

## 5) فرضیه گروه‌بندی بر اساس Prefix کد کالا (A_Code)

### 5.1 فرضیه

* گروه‌بندی از طریق ۲ رقم اول (گروه اصلی) و ۲ رقم بعدی (زیرگروه) در `A_Code`.

### 5.2 یافته‌های قطعی

* توزیع Prefix2 و Prefix4 شمارش شد و نشان می‌دهد می‌تواند مبنای دسته‌بندی باشد.

### 5.3 وضعیت (هنوز غیرقطعی)

* مثال موجود: `A_Code=0403056` دارای `M_Code=02` ولی `Prefix2=04` و `Prefix4=0403` ⇒ لزوماً برابر نیست.
* چون `M_Code` برای اکثر کالاها NULL است، correlation قطعی فعلاً محدود است.

**نتیجه مدیریتی**

* فرضیه Prefix محتمل است ولی بدون UI/Trace نباید مبنای اتوماسیون نهایی شود.

---

## 6) خروجی‌های هدف و وضعیت فعلی

### 6.1 خروجی لیست کالاها (قطعی)

* از `ARTICLE`:

  * `A_Code, A_Name, Sel_Price, Exist, Exist2`
* قیمت تحلیلی:

  * Join با `ArticlePrice` برای `SelID=1` (با مدیریت Missing)

### 6.2 تاریخچه فاکتور (قطعی در داده)

* قیمت آیتم فاکتور در `FACTART.Price_BS` است.
* تغییر قیمت مرجع نباید تاریخچه را خراب کند.

**غیرقطعی**

* گزارش‌های UI باید تست شوند تا مطمئن شویم همیشه از `Price_BS` استفاده می‌کنند.

### 6.3 گروه/زیرگروه (فعلاً غیرقطعی)

* به دلیل NULL بودن `M_Code` و خالی بودن `Artclass/HLP_` مسیر قطعی استخراج گروه برای اکثر کالاها موجود نیست.

---

## 7) تصمیم کلیدی: «قیمت اصلی» از کجا؟

### 7.1 واقعیت داده (قطعی)

دو محل قیمت داریم:

* `ARTICLE.Sel_Price`
* `ArticlePrice.Sel_Price` (برای `SelID=1`)

و اختلاف/ناقصی گسترده مشاهده شده است.

### 7.2 پیشنهاد عملی برای MVP

* **قیمت اصلی API = `ARTICLE.Sel_Price`**
* `ArticlePrice(SelID=1)` به عنوان:

  * فیلد تحلیلی (تاریخ تغییر `ModifyDate`)
  * یا override/fallback در صورت وجود رکورد (بر اساس سیاست تیم)

> سیاست نهایی باید با UI/Trace قطعی شود (بخش 8).

---

## 8) برنامه قطعی‌سازی (Next Steps)

### 8.1 قطعی‌سازی منبع قیمت مرجع (فوری)

**روش قطعی‌تر**

* SQL Server Profiler/Trace هنگام تغییر قیمت در UI
* تشخیص دقیق جدول/Stored Procedure که هلو می‌نویسد

**روش جایگزین**

* تست کنترل‌شده:

  1. ثبت قبل: ARTICLE + ArticlePrice
  2. تغییر از UI
  3. ثبت بعد
     ⇒ مسیر واقعی مشخص می‌شود.

### 8.2 قطعی‌سازی عدم تغییر فاکتورهای قدیمی

* یک فاکتور قدیمی را قبل/بعد از تغییر قیمت مرجع بررسی کنید.
* اگر تغییر کرد، گزارش ریسک‌دار است و باید در Trace مسیرش پیدا شود.

### 8.3 قطعی‌سازی `Exist2`

* تغییر `Exist2` و بررسی در UI (موجودی/کاردکس/انبار)
* اگر mismatch بود ⇒ Trace برای منبع واقعی موجودی لازم است.

### 8.4 کشف مسیر واقعی گروه‌بندی

* گروه‌بندی یک کالا در UI + Trace
* استخراج متن Viewها و بررسی Joinها

---

## 9) Query Pack (کوئری‌های آماده استفاده)

### 9.1 وضعیت کالا در ARTICLE

```sql
SELECT A_Code, A_Name, Sel_Price, Exist, Exist2, M_Code
FROM dbo.ARTICLE
WHERE A_Code = '0101182';
```

### 9.2 قیمت‌ها در ArticlePrice

```sql
SELECT A_Code, SelID, Sel_Price, ModifyDate
FROM dbo.ArticlePrice
WHERE A_Code = '0101182'
ORDER BY SelID;
```

### 9.3 قیمت آیتم‌های فاکتور

```sql
SELECT TOP 200 *
FROM dbo.FACTART
WHERE A_Code = '0101182';
```

### 9.4 شمارش کالاهای بدون گروه

```sql
SELECT
  SUM(CASE WHEN M_Code IS NULL OR LTRIM(RTRIM(M_Code))='' THEN 1 ELSE 0 END) AS ItemsWithoutMCode,
  SUM(CASE WHEN M_Code IS NOT NULL AND LTRIM(RTRIM(M_Code))<>'' THEN 1 ELSE 0 END) AS ItemsWithMCode,
  COUNT(*) AS Total
FROM dbo.ARTICLE;
```

### 9.5 Join گروه اصلی

```sql
SELECT a.A_Code, a.A_Name, a.M_Code, g.M_groupname
FROM dbo.ARTICLE a
LEFT JOIN dbo.M_GROUP g ON a.M_Code = g.M_groupcode
WHERE a.A_Code='0101182';
```

### 9.6 شمارش Artclass و HLP_

```sql
SELECT COUNT(*) AS ArtclassCnt FROM dbo.Artclass;
SELECT COUNT(*) AS HlpCnt FROM dbo.HLP_;
```

### 9.7 استخراج ساختار جدول‌ها

```sql
EXEC sp_help 'dbo.ARTICLE';
EXEC sp_help 'dbo.ArticlePrice';
EXEC sp_help 'dbo.FACTART';
EXEC sp_help 'dbo.M_GROUP';
EXEC sp_help 'dbo.S_GROUP';
```

### 9.8 استخراج متن Viewها

```sql
EXEC sp_helptext 'dbo.W_ShowArticleForSearch_Big';
EXEC sp_helptext 'dbo.W_ShowArticleForSearchCodes';
```

### 9.9 بررسی Triggerها روی جداول کلیدی

```sql
SELECT
  t.name  AS TableName,
  tr.name AS TriggerName,
  tr.is_disabled,
  tr.is_instead_of_trigger
FROM sys.triggers tr
JOIN sys.tables t ON tr.parent_id = t.object_id
WHERE t.name IN ('ARTICLE', 'ArticlePrice', 'FACTART', 'M_GROUP', 'S_GROUP')
ORDER BY t.name, tr.name;
```

---

## 10) ریسک‌ها و نکات احتیاطی

* Update مستقیم قیمت بدون دانستن مسیر UI ممکن است:

  * باعث mismatch بین فرم‌ها/گزارش‌ها شود
  * اختلاف‌های موجود را بیشتر کند
* Update موجودی ممکن است توسط محاسبات داخلی/بستن دوره override شود (تا UI/Trace تأیید نشود، write توصیه نمی‌شود)
* گروه‌بندی: قبل از کشف مسیر واقعی UI، اتوماسیون گروه‌بندی ریسک بالاست.

---

## 11) جمع‌بندی مدیریتی برای تحویل

* `ARTICLE` منبع قطعی کد/نام/موجودی‌ها و یک قیمت (`Sel_Price`) است.
* `ArticlePrice` منبع قطعی قیمت‌های سطح‌بندی‌شده است ولی در داده فعلی ناقص/دارای اختلاف گسترده با ARTICLE است.
* `FACTART.Price_BS` قیمت واحد فاکتور را مستقل نگه می‌دارد؛ تغییر قیمت مرجع نباید تاریخچه را خراب کند (مشروط به گزارش‌های خاص).
* گروه‌بندی هنوز مسیر قطعی ندارد؛ `M_Code` تقریباً خالی و `Artclass/HLP_` خالی‌اند.
* Next Steps: Trace/Profiler + تحلیل Viewها + تست UI کنترل‌شده.

---

## 12) چک‌لیست تحویل برای تیم بعدی

1. متن Viewهای جستجو را استخراج و بررسی کند (`sp_helptext`).
2. تغییر قیمت در UI انجام دهد و همزمان Trace بگیرد.
3. گروه‌بندی کالا در UI انجام دهد و Trace بگیرد.
4. فاکتور قدیمی را قبل/بعد از تغییر قیمت مرجع بررسی کند.
5. `Exist2` را در UI موجودی/کاردکس کنترل کند (در صورت mismatch، Trace).

```

اگر می‌خواهی، من همین Markdown را یک مرحله حرفه‌ای‌تر هم می‌کنم:
- اضافه کردن بخش `Known Issues` و `Open Questions`
- اضافه کردن جدول خلاصه‌ی “قطعی‌ها/غیرقطعی‌ها”
- اضافه کردن `Decision Log` برای «قیمت اصلی = ARTICLE.Sel_Price در MVP» و دلیلش
```
